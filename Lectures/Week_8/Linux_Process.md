# Процеси в Linux

---
## Съдържание

- Как работят процесите?
- Извеждане на процеси
- Управление на процеси
---
## Как работят процесите

- Когато се стартира системата се пуска програма, наречена **init**
- **init** след това изпълнява редица от **init** скриптове, които стартират системните услуги
- Много от системните услуги работят на фонов режим като **daemon** програми
---
- Ядрото пази информация за всеки процес (най-често в папката /proc )
- Всеки процес си има уникален номер, наречен **process ID (PID)**
- **PID** се задават във възходящ ред, **init** винаги има PID 1.
- като файловете процесите също собственици, id-та и др.
---
## Извеждане на процеси

- **ps** - Извежда информация за текущите процеси

```bash
user@system:~ $ ps
    PID TTY          TIME CMD
  79076 pts/2    00:00:00 zsh
  79402 pts/2    00:00:00 ps
```
---
- **PID** - id-то на процеса
- **TTY** - от кой терминал се управлява процеса
- **TIME** - CPU времето, използвано от процеса
- **CMD** - името на процеса
---
- **ps x** или **ps -f** - разширява информацията за процесите. Показва всеки процес, притежаван от потребителя.

```bash
user@system:~ $ ps x
    PID TTY      STAT   TIME COMMAND
   2599 ?        Ss     0:01 /usr/lib/systemd/systemd --user
   2601 ?        S      0:00 (sd-pam)
   2619 ?        Sl     0:05 /usr/bin/gnome-keyring-daemon --daemonize --login
   2634 tty2     Ssl+   0:00 /usr/libexec/gdm-wayland-session /usr/bin/gnome-session
...
```

---
- **STAT** - Състоянието на процеса

| Състояние | Значение                                            |
| --------- | --------------------------------------------------- |
| R         | **Running**: Процесът работи или е готов да работи. |
| S         | **Sleeping**: Процесът чака са определено явление.  |
| D         | **Uninterruptible sleep**: Процесът чака за I/O.    |
| T         | **Stopped**: Процесът е инструктиран да спре.       |

---

| Състояние | Значение                                                        |
| --------- | --------------------------------------------------------------- |
| Z         | **Zombie**: Процесът е спрян, но не е изчистен от родителят си. |
| <         | **High-Priority**: Високо приоритетен процес.                   |
| N         | **Low-Priority**: Ниско приоритетен процес.                     |

---
**ps aux** (BSD style)  - извежда процесите на всеки потребител

```bash
user@system:~ $ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0  25416 15568 ?        Ss   07:18   0:02 /usr/lib/systemd/systemd --switched-root --system --deserializ
root           2  0.0  0.0      0     0 ?        S    07:18   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        S    07:18   0:00 [pool_workqueue_release]
```

---
- **USER** - User ID. Собственика на процеса.
- **%CPU** - Процент от **CPU**, използван от процеса.
- **%МЕМ** - Процент от паметта, използван от процеса.
- **VSZ** - размер на виртуалната памет
---
- **RSS** - размер на физическата памет, използвана от процеса.
- **START** - времето, когато е започнат процеса. За стойности над 24 часа се използва дата.
---
## Сортиране на процесите

- Чрез опцията `--sort` може да сортираме по дадено поле
```bash
ps aux --sort=rss # сортира по паметта във възходящ ред
ps aux --sort=-rss # сортира по паметта в низходящ ред
ps aux --sort=%cpu # сортира по процесора във възходящ ред
```

---
## Персонализиране на изхода

- Чрез опцията `-ef` извеждаме детайлна информация за всеки потребител (UNIX Style)
- Чрез опцията `-o` може да изберем кои полета да се изведат
```bash
ps -efo user,pid # извежда потребител и pid
ps -efo user,pid,command # извежда потребител, pid и команда
```

---
## Процеси на потребител

- Чрез опцията `-u` може да изберем само процесите на конкретен потребител
```bash
ps -u root # извежда процесите на root
ps -u $(whoami) # извежда процесите на текущия потребител
```

---
## Динамично извеждане на процеси

- **top** - дават актуална информация за вървящите процеси
- **htop** - добавя функционалности за търсене, филтриране и убиване на процеси
---

## Управление на процеси

- Ще използва програмата "xlogo" за пример
- Това е програма, която извежда прозорец с символ "x" на екрана
```bash
xlogo
```

---
## Прекъсване на процес

- Повечето пъти ако искаме да прекъснем една работеща програма може на направим чрез комбинацията "Ctrl + C"

```bash
user@system:~ $ xlogo
^C
```

---
## Слагане на процес във фона

- Ако искаме да пуснем програма да върви във "фона", тогава можем да сложим "&" след командата.
```bash
user@system:~ $ xlogo &
[1] 391878
```

---
## Извеждане на пуснати процеси

- Ако искаме да видим програмите, които сме пуснали (дори и във фонов режим), можем да използваме командата **jobs**.
```bash
user@system:~ $ xlogo &
[1] 391878
user@system:~ $ jobs
[1]  + running    xlogo
```

---

- Ако искаме да "върнем" една програма обратно в терминала можем да използваме командата **fg**.

```bash
user@system:~ $ xlogo &
[1] 391878
user@system:~ $ jobs
[1]  + running    xlogo
user@system:~ $ fg %1
xlogo
```

---
## Пауза на процес

- Ако искаме да сложим пауза на даден процес можем да използваме "Ctrl+z"
```bash
user@system:~ $ xlogo
^Z
[1]  + 442257 suspended  xlogo
```

---

- Ако искаме да върнем започнем един спрян процес можем чрез **fg**. Освен това можем да използваме **bg** за възобновим във фонов режим.

```bash
user@system:~ $ bg %1
[1] + xlogo &
```

---
## Убиване на процес

- Използваме **kill** командата, за да "убием" даден процес.

```bash
user@system:~ $ xlogo &
[1] 450577
user@system:~ $ kill 450577
[1]  + 450577 terminated  xlogo
```

---
## Сигнали

- можем да използваме командата **kill**, за да изпращаме различни сигнали на процесите.
```bash
kill [-signal] PID
```

---

| Номер | Име | Значение                                                                                 |
| ----- | --- | ---------------------------------------------------------------------------------------- |
| 1     | HUP | Hangup. Използва се при затваряне на терминала и при реинициализация на daemon програми. |
| 2     | INT | Interrupt. Изпълнява същата функция като "Ctrl+c".                                       |

---

| Номер | Име  | Значение                                                                                                         |
| ----- | ---- | ---------------------------------------------------------------------------------------------------------------- |
| 9     | KILL | Kill. Специален сигнал. Изпраща се към ядрото, което веднага убива програмата. Не дава възможност за изчистване. |
| 15    | TERM | Terminate. Подразбиращият се сигнал. Ако програмата е още в състояние да приема сигнали, ще приключи.            |

---

| Номер | Име  | Значение                                                                               |
| ----- | ---- | -------------------------------------------------------------------------------------- |
| 18    | CONT | Continue. Възстановява процес след STOP или TSTP.                                      |
| 19    | STOP | Stop. Слага програмата на пауза. Подобно на KILL не може да се игнорира от програмата. |
| 20    | TSTP | Terminal stop. Подобно на STOP, но се праща на програмата и може да се игнорира.       |

---

```bash
user@system:~ $ xlogo &
[1] 13601
user@system:~ $ kill -INT 13601
[1]+ Interrupt
xlogo
user@system:~ $ xlogo &
[1] 13608
user@system:~ $ kill -SIGINT 13608
[1]+ Interrupt
xlogo
```

---

- **kil -l** - Дава пълен списък с възможните сигнали
```bash
user@system:~ $ kill -l
HUP INT QUIT ILL TRAP IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS
```

---
## Убиване на множество процеси

- Ако няколко процеса изпълнява една и съща команда, ние можем да ги убием наведнъж чрез **killall**

```bash
killall [-u user] [-signal] name...
```

---

```bash
user@system:~ $ xlogo &
[1] 18801
user@system:~ $ xlogo &
[2] 18802
user@system:~ $ killall xlogo
[1]- Terminated
xlogo
[2]+ Terminated
xlogo
```

---
## Приоритет

- **Linux scheduler** избира следващият процес, който да се изпълни.
- Процеси с висок приоритет ще се изпълнят преди процеси с нисък приоритет.
- Приоритет се определя от реалният приоритет (**pr**) и "милостта" (**ni**)
---
## Niceness

- Начин на модифицираме приоритета на потребителските програми
- Стойността варира от -20 (най-висок приоритет) до 19 (най-нисък приоритет)
- Колко е по-голяма **nice** стойността, толкова е по-нисък приоритета

---
## Извеждане на Niceness

- Можем да използваме командите `ps -l` или `htop`, за да видим колко nice е един процес
```bash
user@system:~ $ xlogo &
[1] 337669
user@system:~ $ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  337423    3686  0  80   0 - 58845 sigsus pts/1    00:00:00 zsh
0 S  1000  337669  337423  0  85   5 -  3306 do_sys pts/1    00:00:00 xlogo
4 R  1000  337841  337423  0  80   0 - 58188 -      pts/1    00:00:00 ps
yordan@fedora:~ $ ps -f

```

---

- **nice** командата ни позволява да започнем процес с добавен "nice value".
```bash
nice -n <nice-value> <command>
```

---

- **renice** ни позволява да променим "nice value" на съществуващ процес.
```bash
renice -n 5 -p <PID>
```

---

- чрез **renice** потребителите могат само да зададат по-голямо "nice value"
- ако искаме да го намалим ни трябват **sudo** привилегии
---
## Истински приоритет

- Представя как приоритетът се разглежда от операционната система
- Смята се различно за **real-time** и **non-real-time** процеси
---
## Потребителски процеси

- Не е нужно да се изпълняват в реално време
- Приоритетът се смята по следната формула
$$ PR = 20 + NI $$

- **PR** - приоритет; **NI** - nice value

---
- Варира от 0 (най-висок приоритет) до 39 (най-нисък)
- По такъв начин се изразява приоритета в **top** и **htop**
---
## Real Time Процеси

- Процеси, които трябва да се изпълнят в даден момент, ред
- Приоритетът им е се определя от самата операционна система
- Стойността на приоритета варира от 0 (най-висок) до 100 (най-нисък)
---

- от гледна точка на ядрото приоритетите на процесите се намират на една скала от 0 до 140, като:
    - 0-100 - real-time процеси
    - 101-140 - потребителски процеси
---

![](/Attachments/OS_Linux_Process_Pic_1.png)

---
